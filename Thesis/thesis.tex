\documentclass{report}

\usepackage[sort&compress,numbers]{natbib}
\usepackage{multicol}
\usepackage{etoolbox}
\usepackage{subfig}
\usepackage{tikz}
\usetikzlibrary{
    calligraphy,
    colorbrewer,
    decorations.markings,
    decorations.pathreplacing,
    patterns,
    spy,
    }
\usepackage{float}
\usepackage[framemethod=default]{mdframed}
\usepackage[a4paper, margin=1in]{geometry}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{graphicx}

% pgf plots and tables
\usepackage{filecontents}
\usepackage{colortbl}
\usepackage{hhline}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\pgfplotsset{compat=1.18}

% Minted for text
\usepackage{minted}
    \setminted[haskell]{
        frame=lines,
        framesep=2mm,
        linenos
    }
    \setminted[cuda]{
        frame=lines,
        framesep=2mm,
        linenos
    }

% Math symbols
\usepackage{amsmath}
\usepackage{amssymb}

\setlist{noitemsep, topsep=0pt}

\newcommand{\TODO}[1]{\noindent{\color{red}\textbf{[TODO] #1}}}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newrobustcmd*{\fsquare}[1]{\tikz{\filldraw[draw=#1,fill=#1] (0,0) rectangle (0.22cm,0.22cm);}}

\pgfplotstableset{
  /color cells/min/.initial=0,
  /color cells/max/.initial=1000,
  /color cells/textcolor/.initial=,
  color cells/.style={
    postproc cell content/.append code={%
          \pgfkeys{/color cells/.cd,#1}%
      \pgfkeysgetvalue{/pgfplots/table/@preprocessed cell content}\value%
      \ifx\value\empty%
      \else%
        \pgfmathfloatparsenumber{\value}\pgfmathfloattofixed{\pgfmathresult}%
        \let\value=\pgfmathresult%
        \pgfplotscolormapaccess%
            [\pgfkeysvalueof{/color cells/min}:\pgfkeysvalueof{/color cells/max}]%
            {\value}{\pgfkeysvalueof{/pgfplots/colormap name}}%
        \pgfkeysgetvalue{/pgfplots/table/@cell content}\typesetvalue%
        \pgfkeysgetvalue{/color cells/textcolor}\textcolorvalue%
        \toks0=\expandafter{\typesetvalue}%
        \edef\temp{\noexpand\pgfkeyssetvalue{/pgfplots/table/@cell content}{%
            \noexpand\cellcolor[rgb]{\pgfmathresult}%
            \noexpand\definecolor{mapped color}{rgb}{\pgfmathresult}%
            \ifx\textcolorvalue\empty\else\noexpand\color{\textcolorvalue}\fi%
            \the\toks0%
          }%
        }%
        \temp%
      \fi%
      }%
  }%
}%

\pgfplotsset{
    % this *defines* a custom colormap ...
    colormap={viridis-light}{
        rgb255=(33,145,140),
        rgb255=(34,168,132),
        rgb255=(68,191,112),
        rgb255=(122,209,81),
        rgb255=(189,223,38),
        rgb255=(254,231,36),
        rgb255=(255,255,255),
    }
}

\tikzset{
    thread/.pic={
        \draw[->,decorate, decoration={snake}] (0, 0.9) -- +(0, -0.8);
    }
}

\tikzset{
    threadblock/.pic={
        \draw (0, 0) rectangle +(2, 1);
        \foreach \x in {1,2,3,8,9,10} {
            \pic at ({\x / 5.5}, 0) {thread};
        }
        \node at (1, 0.5) [scale=0.75] {\dots};
    }
}

\tikzset{
    warp/.pic={
        \draw (0, 0) rectangle +(1, 1);
        \pic at (0.2, 0) {thread};
        \node at (0.6, 0.5) {$\times 32$};
    }
}

\tikzset{
    ->-/.style={decoration={
        markings,
        mark=at position .5 with {\arrow{>}}},postaction={decorate}
    }
}

\tikzset{
    sm_warp/.pic={
        \draw (0,  0  ) rectangle +(2, -1.0) node[pos=.5,align=center] {Warp\\Scheduler};
        \draw (0, -1  ) rectangle +(2, -0.5) node[pos=.5] {$16\times$FP32};
        \draw (0, -1.5) rectangle +(2, -0.5) node[pos=.5] { $8\times$FP64};
        \draw (0, -2  ) rectangle +(2, -0.5) node[pos=.5] {$16\times$INT32};
    }
}

\title{Improving Performance in Structured GPGPU Workloads via Specialized Thread Schedules}
\author{Naraenda Prasetya}
\date{2022}

\begin{document}

\maketitle

\chapter*{Abstract}
Efficient cache utilization is critical in programs with high data throughput.
Improving performance in this area often requires niche knowledge of computer architecture, extensive benchmarking, and algorithms that do more than intuively required.
By changing the order on which tasks are executed, the order in wich memory gets accessed gets changed, which allows us to manipulate how caches get used.
This thesis proposes a column based iterator which reschedules a 2D workload.
We show that performance can be increased compared to the naive method by implementing the proposed method as a native CUDA and as an extension to the data parallelization DSL Accelerate.

\tableofcontents

\chapter{Introduction}
\label{chap:introduction}
\input{chapters/01_introduction.tex}

\chapter{Background}
\label{chap:background}
\input{chapters/02_background.tex}

\chapter{Analysis of Existing Approaches}
\label{chap:analysis}
\input{chapters/03_analysis.tex}

\chapter{Column Based Iteration}
\label{chap:cbi}
\input{chapters/04_implementation.tex}

\chapter{Results}
\label{chap:results}
\input{chapters/05_results.tex}

\chapter{Conclusion}
\label{chap:conclusion}
\input{chapters/06_conclusion.tex}

\bibliographystyle{unsrtnat}
\bibliography{bibliography}
\end{document}
